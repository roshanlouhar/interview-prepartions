- Design clear & secure APIs
- Use auto scaling for traffic spikes
- Index databases to optimize reads
- Assume failures. Make it fault-tolerant
- Partition and shard data for large datasets
- Shard SQL databases for horizontal scaling
- Use CDNs to reduce latency for global users
- Use websockets for real-time communication
- Use write-through cache for write-heavy apps
- Use an API gateway for multiple microservices
- Use microservices over monoliths for scalability
- Denormalize databases for read-heavy workloads
- Use SQL for structured data and ACID transactions
- Use load balancers for traffic distribution and availability
- Implement data replication and redundancy for fault tolerance
- Clarify functional and non-functional requirements before designing
- Add functionality only when needed. Avoid over-engineering
- Use rate limiting to prevent overload and DOS attacks
- Use heartbeats/health checks for failure detection
- Use the circuit breaker pattern to prevent failures
- Use message queues for async communication
- Make operations idempotent to simplify retries
- Use read-through cache for read-heavy apps
- Use event-driven architecture for decoupling
- Use async processing for non-urgent tasks
- Use data lakes or warehouses for analytics
- Prefer horizontal scaling for scalability
- No perfect solutionâ€”only trade-offs
- Use NoSQL for unstructured data
- Use blob storage for media files